# file opened: main.asm
  1   0000              ;===========================================================================
  2   0000              ; main.asm
  3   0000              ;===========================================================================
  4   0000
  5   0000                  DEVICE ZXSPECTRUM128
  6   0000
  7   0000
  8   0000                  ORG 0x4000
  9   4000 00 00 00...      defs 0x6000 - $    ; move after screen area
 10   6000 00           screen_top: defb    0   ; WPMEM
 11   6001
 12   6001
 13   6001              ;===========================================================================
 14   6001              ; Persistent watchpoint.
 15   6001              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
 16   6001              ; If you do so the program will hit a breakpoint when it tries to
 17   6001              ; write to the first byte of the 3rd line.
 18   6001              ; When program breaks in the fill_memory sub routine please hover over hl
 19   6001              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 20   6001              ;===========================================================================
 21   6001
 22   6001              ; WPMEMx 0x5840, 1, w
 23   6001
 24   6001
 25   6001              ;===========================================================================
 26   6001              ; Include modules
 27   6001              ;===========================================================================
 28   6001                  include "utilities.asm"
# file opened: utilities.asm
  1+  6001              ;===========================================================================
  2+  6001              ; utilities.asm
  3+  6001              ; Submodule for some common routines.
  4+  6001              ;===========================================================================
  5+  6001
  6+  6001              ; Some constants
  7+  6001              PAUSE_TIME:     equ 5000   ; 0.5 sec
  8+  6001
  9+  6001
 10+  6001              ; Pauses for a while.
 11+  6001              ; de: wait time, ca: de*0.1ms
 12+  6001              pause:
 13+  6001 C9           	ret	; comment this line if you would like to see a pause between drawing of the lines.
 14+  6002
 15+  6002 F5           	push af
 16+  6003 C5           	push bc
 17+  6004
 18+  6004              pause_loop_l2:
 19+  6004 06 1A        	ld b,26
 20+  6006              pause_loop_l1:
 21+  6006 10 FE        	djnz pause_loop_l1 ; 1 cycle should be roughly 100us=0.1ms
 22+  6008
 23+  6008 1B           	dec de
 24+  6009 7A           	ld a,d
 25+  600A B3           	or e
 26+  600B 20 F7        	jr nz,pause_loop_l2
 27+  600D
 28+  600D C1           	pop bc
 29+  600E F1           	pop af
 30+  600F C9           	ret
 31+  6010
# file closed: utilities.asm
 29   6010
 30   6010                  ; org this include in fast memory
 31   6010              @SlowMemFree    = $
 32   6010                  org #8000
 33   8000                  include "fill.asm"
# file opened: fill.asm
  1+  8000              ;===========================================================================
  2+  8000              ; fill.asm
  3+  8000              ; Submodule with memory fill routines.
  4+  8000              ;===========================================================================
  5+  8000
  6+  8000              ; Some constants
  7+  8000              BCKG_LINE_SIZE:  equ     32
  8+  8000
  9+  8000              ; Colors
 10+  8000              BLACK:          equ 0<<3
 11+  8000              BLUE:           equ 1<<3
 12+  8000              RED:            equ 2<<3
 13+  8000              MAGENTA:        equ 3<<3
 14+  8000              GREEN:          equ 4<<3
 15+  8000              CYAN:           equ 5<<3
 16+  8000              YELLOW:         equ 6<<3
 17+  8000              WHITE:          equ 7<<3
 18+  8000
 19+  8000
 20+  8000              ; Fills a memory area with a certain value.
 21+  8000              ; a = contains the fill value.
 22+  8000              ; hl = address to fill
 23+  8000              ; bc = size
 24+  8000              fill_memory:
 25+  8000 77               ld (hl),a
 26+  8001 5D               ld e,l
 27+  8002 54               ld d,h
 28+  8003 13               inc de
 29+  8004 0B               dec bc
 30+  8005 ED B0            ldir
 31+  8007 C9               ret
 32+  8008
 33+  8008
 34+  8008              ; Fills a background line with a color.
 35+  8008              ; IN:
 36+  8008              ; a = color
 37+  8008              ; de = points to background screen
 38+  8008              ; OUT:
 39+  8008              ; de = pointing to next line
 40+  8008              fill_bckg_line:
 41+  8008 01 20 00         ld bc,BCKG_LINE_SIZE
 42+  800B 6B               ld l,e
 43+  800C 62               ld h,d
 44+  800D CD 00 80         call fill_memory
 45+  8010                  ; check that destination address is still in screen background
 46+  8010 21 FF 5A         ld hl,COLOR_SCREEN+COLOR_SCREEN_SIZE-1
 47+  8013 B7               or a    ; clear carry
 48+  8014 ED 52            sbc hl,de ; compare
 49+  8016 F0               ret p
 50+  8017                  ; ld start address
 51+  8017 11 00 58         ld de,COLOR_SCREEN
 52+  801A C9               ret
 53+  801B
 54+  801B
 55+  801B              ; Increments the fill_colors_ptr and resets it if necessary.
 56+  801B              inc_fill_colors_ptr:
 57+  801B 2A 30 80         ld hl,(fill_colors_ptr)
 58+  801E 23               inc hl
 59+  801F 22 30 80         ld (fill_colors_ptr),hl
 60+  8022
 61+  8022                  ; check if out of range
 62+  8022 01 37 80         ld bc,fill_colors_end
 63+  8025 B7               or a    ; clear carry
 64+  8026 ED 42            sbc hl,bc ; compare
 65+  8028 F8               ret m
 66+  8029
 67+  8029                  ; reset
 68+  8029 21 32 80         ld hl,fill_colors
 69+  802C 22 30 80         ld (fill_colors_ptr),hl
 70+  802F C9               ret
 71+  8030
 72+  8030
 73+  8030              ; Pointer to fill colors.
 74+  8030 00 00        fill_colors_ptr:    defw 0
 75+  8032
 76+  8032              ; Contains the colors for the lines. Each entry represnts the color for one line.
 77+  8032              fill_colors:
 78+  8032 10 30 08 20      defb RED, YELLOW, BLUE, GREEN, MAGENTA
 78+  8036 18
 79+  8037              fill_colors_end:
 80+  8037 00               defb 0  ; WPMEM
 81+  8038
 82+  8038
# file closed: fill.asm
 34   8038
 35   8038                  org @SlowMemFree    ; org the main code back to slow memory
 36   6010                  include "clearscreen.asm"
# file opened: clearscreen.asm
  1+  6010              ;===========================================================================
  2+  6010              ; clearscreen.asm
  3+  6010              ; Submodule to clear the entire screen.
  4+  6010              ;===========================================================================
  5+  6010
  6+  6010              ; Some constants
  7+  6010              SCREEN:         equ 0x4000
  8+  6010              SCREEN_SIZE:    equ 0x1800
  9+  6010
 10+  6010              COLOR_SCREEN:       equ 0x5800
 11+  6010              COLOR_SCREEN_SIZE:  equ 0x0300
 12+  6010
 13+  6010
 14+  6010              ; Clears the screen
 15+  6010              clear_screen:
 16+  6010 AF               xor a
 17+  6011 01 00 18         ld bc,SCREEN_SIZE
 18+  6014 21 00 40         ld hl,SCREEN
 19+  6017 CD 00 80         call fill_memory
 20+  601A C9               ret
 21+  601B
 22+  601B
 23+  601B              ; Clears the background
 24+  601B              clear_backg:
 25+  601B AF               xor a
 26+  601C CD 20 60         call fill_backg
 27+  601F C9               ret
 28+  6020
 29+  6020
 30+  6020              ; Fills the background with fore and background color.
 31+  6020              ; a contains the fill color.
 32+  6020              fill_backg:
 33+  6020 01 00 03         ld bc,COLOR_SCREEN_SIZE
 34+  6023 21 00 58         ld hl,COLOR_SCREEN
 35+  6026 CD 00 80         call fill_memory
 36+  6029 C9               ret
 37+  602A
 38+  602A
 39+  602A
 40+  602A
# file closed: clearscreen.asm
 37   602A
 38   602A                  ; Normally you would assemble the unit tests in a separate target
 39   602A                  ; in the makefile.
 40   602A                  ; As this is a very short program and for simplicity the
 41   602A                  ; unit tests and the main program are assembled in the same binary.
 42   602A                  include "unit_tests.asm"
# file opened: unit_tests.asm
  1+  602A              ;========================================================
  2+  602A              ; unit_tests.asm
  3+  602A              ;
  4+  602A              ; Collects and executes all unit tests.
  5+  602A              ;========================================================
  6+  602A
  7+  602A                  include "unit_tests.inc"
# file opened: unit_tests.inc
  1++ 602A              ;--------------------------------------------------------
  2++ 602A              ; unit_tests.inc
  3++ 602A              ;
  4++ 602A              ; Contains all macros used for unit testing.
  5++ 602A              ;--------------------------------------------------------
  6++ 602A
  7++ 602A                IFDEF _SJASMPLUS
  8++ 602A                  ; -----------------------------------------------------------
  9++ 602A                  ; Code for sjasmplus
 10++ 602A
 11++ 602A                  MACRO UNITTEST_INITIALIZE
 12++ 602A ~
 13++ 602A ~                ; Called to call each unit test.
 14++ 602A ~            @UNITTEST_TEST_WRAPPER:
 15++ 602A ~                    di
 16++ 602A ~                    ld sp,UNITTEST_STACK
 17++ 602A ~            @UNITTEST_CALL_ADDR:
 18++ 602A ~                    call 0x0000 ; Will be changed by the z80 unit tests.
 19++ 602A ~                    nop
 20++ 602A ~
 21++ 602A ~            @UNITTEST_TEST_READY_SUCCESS:
 22++ 602A ~                    jr UNITTEST_TEST_READY_SUCCESS	; A breakpoint will be set here.
 23++ 602A ~
 24++ 602A ~            @UNITTEST_TEST_READY_FAILURE:
 25++ 602A ~                    nop
 26++ 602A ~            @UNITTEST_TEST_READY_FAILURE_BREAKPOINT:
 27++ 602A ~                    ret 	; A breakpoint will be set here. The next step will return to the failed test case
 28++ 602A ~            @UNITTEST_MIN_STACK_GUARD:
 29++ 602A ~                    defw 0	; A write watchpoint will be set here to guard the stack
 30++ 602A ~                    defs 2*50	; Stack depth of 50 should be enough
 31++ 602A ~            @UNITTEST_STACK:
 32++ 602A ~
 33++ 602A ~            @UNITTEST_MAX_STACK_GUARD:
 34++ 602A ~                    defw 0	; A write watchpoint will be set here to guard the stack
 35++ 602A ~
 36++ 602A ~            @UNITTEST_SAVE_REG:
 37++ 602A ~                    defw 0  ; Used to save register values.
 38++ 602A ~
 39++ 602A ~
 40++ 602A ~                ; The unit test initialization. Provided by the user.
 41++ 602A ~            @UNITTEST_START:
 42++ 602A ~                    ; Disable interrupts
 43++ 602A ~                    di
 44++ 602A ~                    ; Flow through.
 45++ 602A ~                    ; Directly after the UNITTEST_INITIALIZE macro the user
 46++ 602A ~                    ; should put his test initialization code.
 47++ 602A ~                    ; Note: the stack pointer does not need to be set up.
 48++ 602A ~
 49++ 602A                  ENDM
 50++ 602A
 51++ 602A
 52++ 602A                  ; Tests a memory address for a specific byte value.
 53++ 602A                  MACRO TEST_MEMORY_BYTE addr?, value?
 54++ 602A ~                    ld (UNITTEST_SAVE_REG),a
 55++ 602A ~                    ld a,(addr?)
 56++ 602A ~                    cp value?
 57++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
 58++ 602A ~                    ld a,(UNITTEST_SAVE_REG)
 59++ 602A                  ENDM
 60++ 602A
 61++ 602A                  ; Tests a memory address for a specific word value.
 62++ 602A                  ; If the test fails the '(addr)' can be found in DE.
 63++ 602A                  MACRO TEST_MEMORY_WORD addr?, value?
 64++ 602A ~                    push de
 65++ 602A ~                    push hl
 66++ 602A ~                    ld hl,value?
 67++ 602A ~                    ld de,(addr?)
 68++ 602A ~                    or a
 69++ 602A ~                    sbc hl,de
 70++ 602A ~                    pop hl
 71++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
 72++ 602A ~                    pop de
 73++ 602A                  ENDM
 74++ 602A
 75++ 602A                  ; Tests A for a specific value.
 76++ 602A                  MACRO TEST_A value?
 77++ 602A ~                    cp value?
 78++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
 79++ 602A ~                    nop
 80++ 602A                  ENDM
 81++ 602A
 82++ 602A                  ; Tests that A is not equal to a specific value.
 83++ 602A                  MACRO TEST_A_UNEQUAL value?
 84++ 602A ~                    cp value?
 85++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
 86++ 602A ~                    nop
 87++ 602A                  ENDM
 88++ 602A
 89++ 602A                  ; Tests a single register for a specific value.
 90++ 602A                  ; E.g. TEST_REG b, 6 ; Tests if register b == 6
 91++ 602A                  MACRO TEST_REG reg?, value?
 92++ 602A ~                    ld (UNITTEST_SAVE_REG),a
 93++ 602A ~                    ld a,reg?
 94++ 602A ~                    cp value?
 95++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
 96++ 602A ~                    ld a,(UNITTEST_SAVE_REG)
 97++ 602A                  ENDM
 98++ 602A
 99++ 602A                  ; Tests that a single register is not a specific value.
100++ 602A                  ; E.g. TEST_REG_UNEQUAL b, 6 ; Tests if register b != 6
101++ 602A                  MACRO TEST_REG_UNEQUAL reg?, value?
102++ 602A ~                    ld (UNITTEST_SAVE_REG),a
103++ 602A ~                    ld a,reg?
104++ 602A ~                    cp value?
105++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
106++ 602A ~                    ld a,(UNITTEST_SAVE_REG)
107++ 602A                  ENDM
108++ 602A
109++ 602A                  ; Tests a double register for a specific value.
110++ 602A                  ; E.g. TEST_REG hl, label1 ; Tests if register hl == label1
111++ 602A                  MACRO TEST_DREG dreg?, value?
112++ 602A ~                    push de
113++ 602A ~                    push hl
114++ 602A ~                    push dreg?
115++ 602A ~                    pop hl
116++ 602A ~                    ld de,value?
117++ 602A ~                    or a
118++ 602A ~                    sbc hl,de
119++ 602A ~                    pop hl
120++ 602A ~                    pop de
121++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
122++ 602A ~                    nop
123++ 602A                  ENDM
124++ 602A
125++ 602A
126++ 602A                   ; Tests a double register for a specific value.
127++ 602A                  ; E.g. TEST_REG hl, label1 ; Tests if register hl == label1
128++ 602A                  MACRO TEST_DREG_UNEQUAL dreg?, value?
129++ 602A ~                    push de
130++ 602A ~                    push hl
131++ 602A ~                    push dreg?
132++ 602A ~                    pop hl
133++ 602A ~                    ld de,value?
134++ 602A ~                    or a
135++ 602A ~                    sbc hl,de
136++ 602A ~                    pop hl
137++ 602A ~                    pop de
138++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE ; de = (addr)
139++ 602A ~                    nop
140++ 602A                  ENDM
141++ 602A
142++ 602A
143++ 602A                  ; Test two registers for equality.
144++ 602A                  ; Testcase fails if registers are not equal.
145++ 602A                  MACRO TEST_DREGS dreg1?, dreg2?
146++ 602A ~                    push de
147++ 602A ~                    push hl
148++ 602A ~                    push dreg1?
149++ 602A ~                    push dreg2?
150++ 602A ~                    pop de
151++ 602A ~                    pop hl
152++ 602A ~                    or a
153++ 602A ~                    sbc hl,de
154++ 602A ~                    pop hl
155++ 602A ~                    pop de
156++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
157++ 602A ~                    nop
158++ 602A                  ENDM
159++ 602A
160++ 602A
161++ 602A                  ; Test two registers for unequality.
162++ 602A                  ; Testcase fails if registers are equal.
163++ 602A                  MACRO TEST_DREGS_UNEQUAL dreg1?, dreg2?
164++ 602A ~                    push de
165++ 602A ~                    push hl
166++ 602A ~                    push dreg1?
167++ 602A ~                    push dreg2?
168++ 602A ~                    pop de
169++ 602A ~                    pop hl
170++ 602A ~                    or a
171++ 602A ~                    sbc hl,de
172++ 602A ~                    pop hl
173++ 602A ~                    pop de
174++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
175++ 602A ~                    nop
176++ 602A                  ENDM
177++ 602A
178++ 602A
179++ 602A                  ; Tests a memory address for a specific string.
180++ 602A                  ; addr = the tested string
181++ 602A                  ; string = the compared string
182++ 602A                  ; term0 = If 0 it is also tested that the string (addr) is null termiated
183++ 602A                  MACRO TEST_STRING addr?, string?, term0?
184++ 602A ~                    push af
185++ 602A ~                    push hl
186++ 602A ~                    push de
187++ 602A ~                    ld de,.comp_string
188++ 602A ~                    ld hl,addr?
189++ 602A ~            .loop:
190++ 602A ~                    ld a,(de)
191++ 602A ~                    ; Check for null termination
192++ 602A ~                    or a
193++ 602A ~                    jr z,.null_found
194++ 602A ~                    cp (hl)
195++ 602A ~                    inc de
196++ 602A ~                    inc hl
197++ 602A ~                    jr z,.loop
198++ 602A ~
199++ 602A ~            .not_equal:
200++ 602A ~                    ; Strings are not equal
201++ 602A ~                    pop de
202++ 602A ~                    pop hl
203++ 602A ~                    pop af
204++ 602A ~                    call UNITTEST_TEST_READY_FAILURE
205++ 602A ~                    jr .end
206++ 602A ~
207++ 602A ~            .comp_string:
208++ 602A ~                    defb string?, 0
209++ 602A ~
210++ 602A ~            .null_found:
211++ 602A ~                    ; We are at the end of the compare string.
212++ 602A ~                    ; Check if null termination should be compared with the tested string.
213++ 602A ~                  IF term0? == 0
214++ 602A ~                    cp (hl)
215++ 602A ~                    jr nz,.not_equal
216++ 602A ~                  ENDIF
217++ 602A ~
218++ 602A ~                    pop de
219++ 602A ~                    pop hl
220++ 602A ~                    pop af
221++ 602A ~            .end:
222++ 602A                  ENDM
223++ 602A
224++ 602A
225++ 602A                  ; Initializes the registers with default values.
226++ 602A                  ; Use before the tested function is called.
227++ 602A                  ; After the call the TEST_UNCHANGED_XX tests can be used
228++ 602A                  ; to check if the register was changed.
229++ 602A                  MACRO DEFAULT_REGS
230++ 602A ~                    ld a,0xAA
231++ 602A ~                    ld bc,0xBBCC
232++ 602A ~                    ld de,0xDDEE
233++ 602A ~                    ld hl,0x8899
234++ 602A                  ENDM
235++ 602A
236++ 602A                  MACRO TEST_UNCHANGED_BC
237++ 602A ~                    push hl
238++ 602A ~                    ld hl,0xBBCC
239++ 602A ~                    or a
240++ 602A ~                    sbc hl,bc
241++ 602A ~                    pop hl
242++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
243++ 602A ~                    nop
244++ 602A                  ENDM
245++ 602A
246++ 602A                  MACRO TEST_UNCHANGED_DE
247++ 602A ~                    push hl
248++ 602A ~                    ld hl,0xDDEE
249++ 602A ~                    or a
250++ 602A ~                    sbc hl,de
251++ 602A ~                    pop hl
252++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
253++ 602A ~                    nop
254++ 602A                  ENDM
255++ 602A
256++ 602A                  MACRO TEST_UNCHANGED_HL
257++ 602A ~                    push de
258++ 602A ~                    ld de,0x8899
259++ 602A ~                    or a
260++ 602A ~                    sbc hl,de
261++ 602A ~                    add hl,de   ; restore hl without affecting the flags
262++ 602A ~                    pop de
263++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
264++ 602A ~                    nop
265++ 602A                  ENDM
266++ 602A
267++ 602A                  MACRO TEST_UNCHANGED_BC_DE
268++ 602A ~                    TEST_UNCHANGED_BC
269++ 602A ~                    TEST_UNCHANGED_DE
270++ 602A                  ENDM
271++ 602A
272++ 602A                  MACRO TEST_UNCHANGED_BC_DE_HL
273++ 602A ~                    TEST_UNCHANGED_BC_DE
274++ 602A ~                    TEST_UNCHANGED_HL
275++ 602A                  ENDM
276++ 602A
277++ 602A                  MACRO TEST_UNCHANGED_A
278++ 602A ~                    TEST_A 0xAA
279++ 602A                  ENDM
280++ 602A
281++ 602A                  MACRO TEST_UNCHANGED_B
282++ 602A ~                    TEST_REG b, 0xBB
283++ 602A                  ENDM
284++ 602A
285++ 602A                  MACRO TEST_UNCHANGED_C
286++ 602A ~                    TEST_REG c, 0xCC
287++ 602A                  ENDM
288++ 602A
289++ 602A                  MACRO TEST_UNCHANGED_D
290++ 602A ~                    TEST_REG d, 0xDD
291++ 602A                  ENDM
292++ 602A
293++ 602A                  MACRO TEST_UNCHANGED_E
294++ 602A ~                    TEST_REG e, 0xEE
295++ 602A                  ENDM
296++ 602A
297++ 602A                  MACRO TEST_UNCHANGED_H
298++ 602A ~                    TEST_REG h, 0x88
299++ 602A                  ENDM
300++ 602A
301++ 602A                  MACRO TEST_UNCHANGED_L
302++ 602A ~                    TEST_REG l, 0x99
303++ 602A                  ENDM
304++ 602A
305++ 602A
306++ 602A                  ; Macro to test flags for Z.
307++ 602A                  ; Testcase fails for NZ.
308++ 602A                  MACRO TEST_FLAG_Z
309++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
310++ 602A ~                    nop
311++ 602A                  ENDM
312++ 602A
313++ 602A
314++ 602A                  ; Macro to test flags for NZ.
315++ 602A                  ; Testcase fails for Z.
316++ 602A                  MACRO TEST_FLAG_NZ
317++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
318++ 602A ~                    nop
319++ 602A                  ENDM
320++ 602A
321++ 602A
322++ 602A                  ; This macro uses all registers, also the shadow registers.
323++ 602A                  MACRO USE_ALL_REGS
324++ 602A ~                    ld a,0xCD
325++ 602A ~                    ld bc,0xBBCC
326++ 602A ~                    ld de,0xDDEE
327++ 602A ~                    ld hl,0xFF11
328++ 602A ~                    ld ix,0x7788
329++ 602A ~                    ld iy,0x99AA
330++ 602A ~                    exx
331++ 602A ~                    ld a,0xDC
332++ 602A ~                    ld bc,0x1122
333++ 602A ~                    ld de,0x3344
334++ 602A ~                    ld hl,0x5566
335++ 602A ~                    exx
336++ 602A                  ENDM
337++ 602A
338++ 602A                  ; sjasmplus end
339++ 602A                  ; -----------------------------------------------------------
340++ 602A
341++ 602A
342++ 602A                ELSE
343++ 602A ~                ; -----------------------------------------------------------
344++ 602A ~                ; Code for other assemblers
345++ 602A ~
346++ 602A ~
347++ 602A ~                ; Tests a memory address for a specific byte value.
348++ 602A ~            TEST_MEMORY_BYTE:    MACRO addr, value
349++ 602A ~                    ld (UNITTEST_SAVE_REG),a
350++ 602A ~                    ld a,(addr)
351++ 602A ~                    cp value
352++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
353++ 602A ~                    ld a,(UNITTEST_SAVE_REG)
354++ 602A ~                ENDM
355++ 602A ~
356++ 602A ~                ; Tests a memory address for a specific word value.
357++ 602A ~                ; If the test fails the '(addr)' can be found in DE.
358++ 602A ~            TEST_MEMORY_WORD:    MACRO addr, value
359++ 602A ~                    push de
360++ 602A ~                    push hl
361++ 602A ~                    ld hl,value
362++ 602A ~                    ld de,(addr)
363++ 602A ~                    or a
364++ 602A ~                    sbc hl,de
365++ 602A ~                    pop hl
366++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
367++ 602A ~                    pop de
368++ 602A ~                ENDM
369++ 602A ~
370++ 602A ~                ; Tests A for a specific value.
371++ 602A ~            TEST_A:    MACRO value
372++ 602A ~                    cp value
373++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
374++ 602A ~                    nop
375++ 602A ~                ENDM
376++ 602A ~
377++ 602A ~                ; Tests that A is not equal to a specific value.
378++ 602A ~            TEST_A_UNEQUAL:    MACRO value
379++ 602A ~                    cp value
380++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
381++ 602A ~                    nop
382++ 602A ~                ENDM
383++ 602A ~
384++ 602A ~                ; Tests a single register for a specific value.
385++ 602A ~                ; E.g. TEST_REG b, 6 ; Tests if register b == 6
386++ 602A ~            TEST_REG:    MACRO reg, value
387++ 602A ~                    ld (UNITTEST_SAVE_REG),a
388++ 602A ~                    ld a,reg
389++ 602A ~                    cp value
390++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
391++ 602A ~                    ld a,(UNITTEST_SAVE_REG)
392++ 602A ~                ENDM
393++ 602A ~
394++ 602A ~                ; Tests that a single register is not a specific value.
395++ 602A ~                ; E.g. TEST_REG_UNEQUAL b, 6 ; Tests if register b != 6
396++ 602A ~            TEST_REG_UNEQUAL:    MACRO reg, value
397++ 602A ~                    ld (UNITTEST_SAVE_REG),a
398++ 602A ~                    ld a,reg
399++ 602A ~                    cp value
400++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
401++ 602A ~                    ld a,(UNITTEST_SAVE_REG)
402++ 602A ~                ENDM
403++ 602A ~
404++ 602A ~                ; Tests a double register for a specific value.
405++ 602A ~                ; E.g. TEST_DREG hl, label1 ; Tests if register hl == label1
406++ 602A ~            TEST_DREG:    MACRO dreg, value
407++ 602A ~                    push de
408++ 602A ~                    push hl
409++ 602A ~                    push dreg
410++ 602A ~                    pop hl
411++ 602A ~                    ld de,value
412++ 602A ~                    or a
413++ 602A ~                    sbc hl,de
414++ 602A ~                    pop hl
415++ 602A ~                    pop de
416++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
417++ 602A ~                    nop
418++ 602A ~                ENDM
419++ 602A ~
420++ 602A ~                ; Tests a double register is not a specific value.
421++ 602A ~                ; E.g. TEST_DREG_UNEQUAL hl, label1 ; Tests if register hl != label1
422++ 602A ~            TEST_DREG_UNEQUAL:    MACRO dreg, value
423++ 602A ~                    push de
424++ 602A ~                    push hl
425++ 602A ~                    push dreg
426++ 602A ~                    pop hl
427++ 602A ~                    ld de,value
428++ 602A ~                    or a
429++ 602A ~                    sbc hl,de
430++ 602A ~                    pop hl
431++ 602A ~                    pop de
432++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
433++ 602A ~                    nop
434++ 602A ~                ENDM
435++ 602A ~
436++ 602A ~
437++ 602A ~                ; Test two registers for equality.
438++ 602A ~                ; Testcase fails if registers are not equal.
439++ 602A ~            TEST_DREGS:    MACRO dreg1, dreg2
440++ 602A ~                    push de
441++ 602A ~                    push hl
442++ 602A ~                    push dreg1
443++ 602A ~                    push dreg2
444++ 602A ~                    pop de
445++ 602A ~                    pop hl
446++ 602A ~                    or a
447++ 602A ~                    sbc hl,de
448++ 602A ~                    pop de
449++ 602A ~                    pop hl
450++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
451++ 602A ~                    nop
452++ 602A ~                ENDM
453++ 602A ~
454++ 602A ~
455++ 602A ~                ; Test two registers for unequality.
456++ 602A ~                ; Testcase fails if registers are equal.
457++ 602A ~            TEST_DREGS_UNEQUAL:    MACRO dreg1, dreg2
458++ 602A ~                    push de
459++ 602A ~                    push hl
460++ 602A ~                    push dreg1
461++ 602A ~                    push dreg2
462++ 602A ~                    pop de
463++ 602A ~                    pop hl
464++ 602A ~                    or a
465++ 602A ~                    sbc hl,de
466++ 602A ~                    pop de
467++ 602A ~                    pop hl
468++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
469++ 602A ~                    nop
470++ 602A ~                ENDM
471++ 602A ~
472++ 602A ~
473++ 602A ~                ; Tests a memory address for a specific string.
474++ 602A ~                ; addr = the tested string
475++ 602A ~                ; string = the compared string
476++ 602A ~                ; term0 = If 0 it is also tested that the string (addr) is null terminated
477++ 602A ~            TEST_STRING:    MACRO addr, string, term0
478++ 602A ~                    push af
479++ 602A ~                    push hl
480++ 602A ~                    push de
481++ 602A ~                    ld de,.comp_string
482++ 602A ~                    ld hl,addr?
483++ 602A ~            .loop:
484++ 602A ~                    ld a,(de)
485++ 602A ~                    ; Check for null termination
486++ 602A ~                    or a
487++ 602A ~                    jr z,.null_found
488++ 602A ~                    cp (hl)
489++ 602A ~                    inc de
490++ 602A ~                    inc hl
491++ 602A ~                    jr z,.loop
492++ 602A ~
493++ 602A ~            .not_equal:
494++ 602A ~                    ; Strings are not equal
495++ 602A ~                    pop de
496++ 602A ~                    pop hl
497++ 602A ~                    pop af
498++ 602A ~                    call UNITTEST_TEST_READY_FAILURE
499++ 602A ~                    jr .end
500++ 602A ~
501++ 602A ~            .comp_string:
502++ 602A ~                    defb string, 0
503++ 602A ~
504++ 602A ~            .null_found:
505++ 602A ~                    ; We are at the end of the compare string.
506++ 602A ~                    ; Check if null termination should be compared with the tested string.
507++ 602A ~                  IF term0 == 0
508++ 602A ~                    cp (hl)
509++ 602A ~                    jr nz,.not_equal
510++ 602A ~                  ENDIF
511++ 602A ~
512++ 602A ~                    pop de
513++ 602A ~                    pop hl
514++ 602A ~                    pop af
515++ 602A ~            .end:
516++ 602A ~                ENDM
517++ 602A ~
518++ 602A ~
519++ 602A ~                ; Initializes the registers with default values.
520++ 602A ~                ; Use before the tested function is called.
521++ 602A ~                ; After the call the TEST_UNCHANGED_XX tests can be used
522++ 602A ~                ; to check if the register was changed.
523++ 602A ~            DEFAULT_REGS:    MACRO
524++ 602A ~                    ld a,0xAA
525++ 602A ~                    ld bc,0xBBCC
526++ 602A ~                    ld de,0xDDEE
527++ 602A ~                    ld hl,0x8899
528++ 602A ~                ENDM
529++ 602A ~
530++ 602A ~            TEST_UNCHANGED_BC:    MACRO
531++ 602A ~                    push hl
532++ 602A ~                    ld hl,0xBBCC
533++ 602A ~                    or a
534++ 602A ~                    sbc hl,bc
535++ 602A ~                    pop hl
536++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
537++ 602A ~                    nop
538++ 602A ~                ENDM
539++ 602A ~
540++ 602A ~            TEST_UNCHANGED_DE:    MACRO
541++ 602A ~                    push hl
542++ 602A ~                    ld hl,0xDDEE
543++ 602A ~                    or a
544++ 602A ~                    sbc hl,de
545++ 602A ~                    pop hl
546++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
547++ 602A ~                    nop
548++ 602A ~                ENDM
549++ 602A ~
550++ 602A ~            TEST_UNCHANGED_HL:    MACRO
551++ 602A ~                    push de
552++ 602A ~                    ld de,0x8899
553++ 602A ~                    or a
554++ 602A ~                    sbc hl,de
555++ 602A ~                    add hl,de   ; restore hl without affecting the flags
556++ 602A ~                    pop de
557++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
558++ 602A ~                    nop
559++ 602A ~                ENDM
560++ 602A ~
561++ 602A ~            TEST_UNCHANGED_BC_DE:    MACRO
562++ 602A ~                    TEST_UNCHANGED_BC
563++ 602A ~                    TEST_UNCHANGED_DE
564++ 602A ~                ENDM
565++ 602A ~
566++ 602A ~            TEST_UNCHANGED_BC_DE_HL:    MACRO
567++ 602A ~                    TEST_UNCHANGED_BC_DE
568++ 602A ~                    TEST_UNCHANGED_HL
569++ 602A ~                ENDM
570++ 602A ~
571++ 602A ~            TEST_UNCHANGED_A:    MACRO
572++ 602A ~                    TEST_A 0xAA
573++ 602A ~                ENDM
574++ 602A ~
575++ 602A ~            TEST_UNCHANGED_B:    MACRO
576++ 602A ~                    TEST_REG b, 0xBB
577++ 602A ~                ENDM
578++ 602A ~
579++ 602A ~            TEST_UNCHANGED_C:    MACRO
580++ 602A ~                    TEST_REG c, 0xCC
581++ 602A ~                ENDM
582++ 602A ~
583++ 602A ~            TEST_UNCHANGED_D:    MACRO
584++ 602A ~                    TEST_REG d, 0xDD
585++ 602A ~                ENDM
586++ 602A ~
587++ 602A ~            TEST_UNCHANGED_E:    MACRO
588++ 602A ~                    TEST_REG e, 0xEE
589++ 602A ~                ENDM
590++ 602A ~
591++ 602A ~            TEST_UNCHANGED_H:    MACRO
592++ 602A ~                    TEST_REG h, 0x88
593++ 602A ~                ENDM
594++ 602A ~
595++ 602A ~            TEST_UNCHANGED_L:    MACRO
596++ 602A ~                    TEST_REG l, 0x99
597++ 602A ~                ENDM
598++ 602A ~
599++ 602A ~
600++ 602A ~                ; Macro to test flags for Z.
601++ 602A ~                ; Testcase fails for NZ.
602++ 602A ~            TEST_FLAG_Z:    MACRO
603++ 602A ~                    call nz,UNITTEST_TEST_READY_FAILURE
604++ 602A ~                    nop
605++ 602A ~                ENDM
606++ 602A ~
607++ 602A ~
608++ 602A ~                ; Macro to test flags for NZ.
609++ 602A ~                ; Testcase fails for Z.
610++ 602A ~            TEST_FLAG_NZ:    MACRO
611++ 602A ~                    call z,UNITTEST_TEST_READY_FAILURE
612++ 602A ~                    nop
613++ 602A ~                ENDM
614++ 602A ~
615++ 602A ~
616++ 602A ~                ; This macro uses all registers, also the shadow registers.
617++ 602A ~            USE_ALL_REGS:    MACRO
618++ 602A ~                    ld a,0xCD
619++ 602A ~                    ld bc,0xBBCC
620++ 602A ~                    ld de,0xDDEE
621++ 602A ~                    ld hl,0xFF11
622++ 602A ~                    ld ix,0x7788
623++ 602A ~                    ld iy,0x99AA
624++ 602A ~                    exx
625++ 602A ~                    ld a,0xDC
626++ 602A ~                    ld bc,0x1122
627++ 602A ~                    ld de,0x3344
628++ 602A ~                    ld hl,0x5566
629++ 602A ~                    exx
630++ 602A ~                ENDM
631++ 602A ~
632++ 602A ~                ; other assemblers end
633++ 602A ~                ; -----------------------------------------------------------
634++ 602A                ENDIF
635++ 602A
# file closed: unit_tests.inc
  8+  602A
  9+  602A
 10+  602A              ; Initialization routine called before all unit tests are
 11+  602A              ; started.
 12+  602A                  UNITTEST_INITIALIZE
 12+  602A             >
 12+  602A             >    ; Called to call each unit test.
 12+  602A             >@UNITTEST_TEST_WRAPPER:
 12+  602A F3          >        di
 12+  602B 31 9C 60    >        ld sp,UNITTEST_STACK
 12+  602E             >@UNITTEST_CALL_ADDR:
 12+  602E CD 00 00    >        call 0x0000 ; Will be changed by the z80 unit tests.
 12+  6031 00          >        nop
 12+  6032             >
 12+  6032             >@UNITTEST_TEST_READY_SUCCESS:
 12+  6032 18 FE       >        jr UNITTEST_TEST_READY_SUCCESS	; A breakpoint will be set here.
 12+  6034             >
 12+  6034             >@UNITTEST_TEST_READY_FAILURE:
 12+  6034 00          >        nop
 12+  6035             >@UNITTEST_TEST_READY_FAILURE_BREAKPOINT:
 12+  6035 C9          >        ret 	; A breakpoint will be set here. The next step will return to the failed test case
 12+  6036             >@UNITTEST_MIN_STACK_GUARD:
 12+  6036 00 00       >        defw 0	; A write watchpoint will be set here to guard the stack
 12+  6038 00 00 00... >        defs 2*50	; Stack depth of 50 should be enough
 12+  609C             >@UNITTEST_STACK:
 12+  609C             >
 12+  609C             >@UNITTEST_MAX_STACK_GUARD:
 12+  609C 00 00       >        defw 0	; A write watchpoint will be set here to guard the stack
 12+  609E             >
 12+  609E             >@UNITTEST_SAVE_REG:
 12+  609E 00 00       >        defw 0  ; Used to save register values.
 12+  60A0             >
 12+  60A0             >
 12+  60A0             >    ; The unit test initialization. Provided by the user.
 12+  60A0             >@UNITTEST_START:
 12+  60A0             >        ; Disable interrupts
 12+  60A0 F3          >        di
 12+  60A1             >        ; Flow through.
 12+  60A1             >        ; Directly after the UNITTEST_INITIALIZE macro the user
 12+  60A1             >        ; should put his test initialization code.
 12+  60A1             >        ; Note: the stack pointer does not need to be set up.
 12+  60A1             >
 13+  60A1                  ; Do your initialization here ...
 14+  60A1                  ; ...
 15+  60A1                  ; ...
 16+  60A1                  ; For this simple example we don't need any special initialization.
 17+  60A1                  ; So we simply return.
 18+  60A1                  ; Please note: the stack pointer does not need to be setup explicitly
 19+  60A1                  ; for the unit tests.
 20+  60A1 C9               ret
 21+  60A2
 22+  60A2
 23+  60A2                  MODULE TestSuite_ClearScreen
 24+  60A2
 25+  60A2              ; A unit testcase needs to start with "UT_" (upper case letters).
 26+  60A2              ; DeZog will collect all these labels and offer them for execution.
 27+  60A2              UT_clear_screen:
 28+  60A2                  ; Write some bytes to the screen area
 29+  60A2 3E FF            ld a,0xFF
 30+  60A4 32 00 40         ld (SCREEN),a
 31+  60A7 32 00 4C         ld (SCREEN+SCREEN_SIZE/2),a
 32+  60AA 32 FF 57         ld (SCREEN+SCREEN_SIZE-1),a
 33+  60AD 32 00 58         ld (SCREEN+SCREEN_SIZE),a
 34+  60B0
 35+  60B0                  ; Now clear the screen
 36+  60B0 CD 10 60         call clear_screen
 37+  60B3
 38+  60B3                  ; Test that all values inside the screen area are cleared
 39+  60B3                  TEST_MEMORY_BYTE SCREEN, 0
 39+  60B3 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 39+  60B6 3A 00 40    >        ld a,(SCREEN)
 39+  60B9 FE 00       >        cp 0
 39+  60BB C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 39+  60BE 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 40+  60C1                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE/2, 0
 40+  60C1 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 40+  60C4 3A 00 4C    >        ld a,(SCREEN+SCREEN_SIZE/2)
 40+  60C7 FE 00       >        cp 0
 40+  60C9 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 40+  60CC 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 41+  60CF                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE-1, 0
 41+  60CF 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 41+  60D2 3A FF 57    >        ld a,(SCREEN+SCREEN_SIZE-1)
 41+  60D5 FE 00       >        cp 0
 41+  60D7 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 41+  60DA 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 42+  60DD
 43+  60DD                  TEST_MEMORY_BYTE SCREEN+SCREEN_SIZE, 0xFF
 43+  60DD 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 43+  60E0 3A 00 58    >        ld a,(SCREEN+SCREEN_SIZE)
 43+  60E3 FE FF       >        cp 0xFF
 43+  60E5 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 43+  60E8 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 44+  60EB C9               ret
 45+  60EC
 46+  60EC
 47+  60EC              ; Tests filling the background.
 48+  60EC              UT_fill_backg:
 49+  60EC                  ; Write some bytes to the screen area
 50+  60EC 3E FF            ld a,0xFF
 51+  60EE 32 00 58         ld (COLOR_SCREEN),a
 52+  60F1 32 80 59         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE/2),a
 53+  60F4 32 FF 5A         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE-1),a
 54+  60F7 32 00 5B         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE),a
 55+  60FA
 56+  60FA                  ; Now fill the background with 128
 57+  60FA 3E 80            ld a,128
 58+  60FC CD 20 60         call fill_backg
 59+  60FF
 60+  60FF                  ; Test that all values inside the screen area are cleared
 61+  60FF                  TEST_MEMORY_BYTE COLOR_SCREEN, 128
 61+  60FF 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 61+  6102 3A 00 58    >        ld a,(COLOR_SCREEN)
 61+  6105 FE 80       >        cp 128
 61+  6107 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 61+  610A 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 62+  610D                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE/2, 128
 62+  610D 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 62+  6110 3A 80 59    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE/2)
 62+  6113 FE 80       >        cp 128
 62+  6115 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 62+  6118 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 63+  611B                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE-1, 128
 63+  611B 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 63+  611E 3A FF 5A    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE-1)
 63+  6121 FE 80       >        cp 128
 63+  6123 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 63+  6126 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 64+  6129
 65+  6129                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE, 0xFF
 65+  6129 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 65+  612C 3A 00 5B    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE)
 65+  612F FE FF       >        cp 0xFF
 65+  6131 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 65+  6134 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 66+  6137 C9               ret
 67+  6138
 68+  6138
 69+  6138              ; Tests clearing the background.
 70+  6138              UT_clear_backg:
 71+  6138                  ; Write some bytes to the screen area
 72+  6138 3E FF            ld a,0xFF
 73+  613A 32 00 58         ld (COLOR_SCREEN),a
 74+  613D 32 80 59         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE/2),a
 75+  6140 32 FF 5A         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE-1),a
 76+  6143 32 00 5B         ld (COLOR_SCREEN+COLOR_SCREEN_SIZE),a
 77+  6146
 78+  6146                  ; Now clear the background
 79+  6146 CD 1B 60         call clear_backg
 80+  6149
 81+  6149                  ; Test that all values inside the screen area are cleared
 82+  6149                  TEST_MEMORY_BYTE COLOR_SCREEN, 0
 82+  6149 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 82+  614C 3A 00 58    >        ld a,(COLOR_SCREEN)
 82+  614F FE 00       >        cp 0
 82+  6151 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 82+  6154 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 83+  6157                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE/2, 0
 83+  6157 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 83+  615A 3A 80 59    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE/2)
 83+  615D FE 00       >        cp 0
 83+  615F C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 83+  6162 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 84+  6165                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE-1, 0
 84+  6165 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 84+  6168 3A FF 5A    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE-1)
 84+  616B FE 00       >        cp 0
 84+  616D C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 84+  6170 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 85+  6173
 86+  6173                  TEST_MEMORY_BYTE COLOR_SCREEN+COLOR_SCREEN_SIZE, 0xFF
 86+  6173 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
 86+  6176 3A 00 5B    >        ld a,(COLOR_SCREEN+COLOR_SCREEN_SIZE)
 86+  6179 FE FF       >        cp 0xFF
 86+  617B C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
 86+  617E 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
 87+  6181 C9               ret
 88+  6182
 89+  6182                  ENDMODULE
 90+  6182
 91+  6182
 92+  6182
 93+  6182                  MODULE TestSuite_Fill
 94+  6182
 95+  6182              ; Tests filling a memory area
 96+  6182              UT_fill_memory:
 97+  6182                  ; Write some bytes
 98+  6182 3E FF            ld a,0xFF
 99+  6184 32 E5 61         ld (fill_memory_data-1),a
100+  6187 32 E6 61         ld (fill_memory_data),a
101+  618A 32 EB 61         ld (fill_memory_data+FILL_MEMORY_SIZE/2),a
102+  618D 32 EF 61         ld (fill_memory_data+FILL_MEMORY_SIZE-1),a
103+  6190 32 F0 61         ld (fill_memory_data+FILL_MEMORY_SIZE),a
104+  6193
105+  6193                  ; Now fill the memory area
106+  6193 3E 16            ld a,22
107+  6195 21 E6 61         ld hl,fill_memory_data
108+  6198 01 0A 00         ld bc,FILL_MEMORY_SIZE
109+  619B CD 00 80         call fill_memory
110+  619E
111+  619E                  ; Test that all values inside the screen area are cleared
112+  619E                  TEST_MEMORY_BYTE fill_memory_data-1, 0xFF
112+  619E 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
112+  61A1 3A E5 61    >        ld a,(fill_memory_data-1)
112+  61A4 FE FF       >        cp 0xFF
112+  61A6 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
112+  61A9 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
113+  61AC                  TEST_MEMORY_BYTE fill_memory_data, 22
113+  61AC 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
113+  61AF 3A E6 61    >        ld a,(fill_memory_data)
113+  61B2 FE 16       >        cp 22
113+  61B4 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
113+  61B7 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
114+  61BA                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE/2, 22
114+  61BA 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
114+  61BD 3A EB 61    >        ld a,(fill_memory_data+FILL_MEMORY_SIZE/2)
114+  61C0 FE 16       >        cp 22
114+  61C2 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
114+  61C5 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
115+  61C8                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE-1, 22
115+  61C8 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
115+  61CB 3A EF 61    >        ld a,(fill_memory_data+FILL_MEMORY_SIZE-1)
115+  61CE FE 16       >        cp 22
115+  61D0 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
115+  61D3 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
116+  61D6
117+  61D6                  TEST_MEMORY_BYTE fill_memory_data+FILL_MEMORY_SIZE, 0xFF
117+  61D6 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
117+  61D9 3A F0 61    >        ld a,(fill_memory_data+FILL_MEMORY_SIZE)
117+  61DC FE FF       >        cp 0xFF
117+  61DE C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
117+  61E1 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
118+  61E4 C9               ret
119+  61E5
120+  61E5
121+  61E5              FILL_MEMORY_SIZE:   equ 10
122+  61E5 00               defb 0
123+  61E6              fill_memory_data:
124+  61E6 00 00 00...      defs 10
125+  61F0 00               defb 0
126+  61F1
127+  61F1
128+  61F1              ; Tests filling a line in the background color screen.
129+  61F1              UT_fill_bckg_line_normal:
130+  61F1                  ; Initialize background
131+  61F1 CD 1B 60         call clear_backg
132+  61F4
133+  61F4                  ; Fill line with color
134+  61F4 3E 18            ld a,MAGENTA
135+  61F6 11 00 58         ld de,COLOR_SCREEN
136+  61F9 CD 08 80         call fill_bckg_line
137+  61FC
138+  61FC                  ; Test that line is filled
139+  61FC                  TEST_MEMORY_BYTE COLOR_SCREEN, MAGENTA
139+  61FC 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
139+  61FF 3A 00 58    >        ld a,(COLOR_SCREEN)
139+  6202 FE 18       >        cp MAGENTA
139+  6204 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
139+  6207 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
140+  620A                  TEST_MEMORY_BYTE COLOR_SCREEN+16, MAGENTA
140+  620A 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
140+  620D 3A 10 58    >        ld a,(COLOR_SCREEN+16)
140+  6210 FE 18       >        cp MAGENTA
140+  6212 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
140+  6215 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
141+  6218                  TEST_MEMORY_BYTE COLOR_SCREEN+31, MAGENTA
141+  6218 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
141+  621B 3A 1F 58    >        ld a,(COLOR_SCREEN+31)
141+  621E FE 18       >        cp MAGENTA
141+  6220 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
141+  6223 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
142+  6226                  TEST_MEMORY_BYTE COLOR_SCREEN+32, 0
142+  6226 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
142+  6229 3A 20 58    >        ld a,(COLOR_SCREEN+32)
142+  622C FE 00       >        cp 0
142+  622E C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
142+  6231 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
143+  6234
144+  6234                  ; Test that de points to the next line
145+  6234                  TEST_DREG de, COLOR_SCREEN+32
145+  6234 D5          >        push de
145+  6235 E5          >        push hl
145+  6236 D5          >        push de
145+  6237 E1          >        pop hl
145+  6238 11 20 58    >        ld de,COLOR_SCREEN+32
145+  623B B7          >        or a
145+  623C ED 52       >        sbc hl,de
145+  623E E1          >        pop hl
145+  623F D1          >        pop de
145+  6240 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
145+  6243 00          >        nop
146+  6244
147+  6244 C9               ret
148+  6245
149+  6245              ; Test wrap around.
150+  6245              UT_fill_bckg_line_wrap_around:
151+  6245                  ; Initialize background
152+  6245 CD 1B 60         call clear_backg
153+  6248
154+  6248                  ; Fill line with color
155+  6248 3E 18            ld a,MAGENTA
156+  624A 11 E0 5A         ld de,COLOR_SCREEN+23*32
157+  624D CD 08 80         call fill_bckg_line
158+  6250
159+  6250                  ; Test that line is filled
160+  6250                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32, MAGENTA
160+  6250 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
160+  6253 3A E0 5A    >        ld a,(COLOR_SCREEN+23*32)
160+  6256 FE 18       >        cp MAGENTA
160+  6258 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
160+  625B 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
161+  625E                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32+16, MAGENTA
161+  625E 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
161+  6261 3A F0 5A    >        ld a,(COLOR_SCREEN+23*32+16)
161+  6264 FE 18       >        cp MAGENTA
161+  6266 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
161+  6269 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
162+  626C                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32+31, MAGENTA
162+  626C 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
162+  626F 3A FF 5A    >        ld a,(COLOR_SCREEN+23*32+31)
162+  6272 FE 18       >        cp MAGENTA
162+  6274 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
162+  6277 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
163+  627A                  TEST_MEMORY_BYTE COLOR_SCREEN+23*32-1, 0
163+  627A 32 9E 60    >        ld (UNITTEST_SAVE_REG),a
163+  627D 3A DF 5A    >        ld a,(COLOR_SCREEN+23*32-1)
163+  6280 FE 00       >        cp 0
163+  6282 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE
163+  6285 3A 9E 60    >        ld a,(UNITTEST_SAVE_REG)
164+  6288
165+  6288                  ; Test that de points to the first line (wrap around)
166+  6288                  TEST_DREG de, COLOR_SCREEN
166+  6288 D5          >        push de
166+  6289 E5          >        push hl
166+  628A D5          >        push de
166+  628B E1          >        pop hl
166+  628C 11 00 58    >        ld de,COLOR_SCREEN
166+  628F B7          >        or a
166+  6290 ED 52       >        sbc hl,de
166+  6292 E1          >        pop hl
166+  6293 D1          >        pop de
166+  6294 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
166+  6297 00          >        nop
167+  6298
168+  6298 C9               ret
169+  6299
170+  6299
171+  6299              ; Test wrap around.
172+  6299              UT_fill_colors_ptr:
173+  6299                  ; Start value
174+  6299 21 32 80         ld hl,fill_colors
175+  629C 22 30 80         ld (fill_colors_ptr),hl
176+  629F
177+  629F                  ; Test increment
178+  629F CD 1B 80         call inc_fill_colors_ptr
179+  62A2                  ; Test that pointer is moved to next line
180+  62A2                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors+1
180+  62A2 D5          >        push de
180+  62A3 E5          >        push hl
180+  62A4 21 33 80    >        ld hl,fill_colors+1
180+  62A7 ED 5B 30 80 >        ld de,(fill_colors_ptr)
180+  62AB B7          >        or a
180+  62AC ED 52       >        sbc hl,de
180+  62AE E1          >        pop hl
180+  62AF C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
180+  62B2 D1          >        pop de
181+  62B3
182+  62B3                  ; Test increment
183+  62B3 CD 1B 80         call inc_fill_colors_ptr
184+  62B6                  ; Test that pointer is moved to next line
185+  62B6                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors+2
185+  62B6 D5          >        push de
185+  62B7 E5          >        push hl
185+  62B8 21 34 80    >        ld hl,fill_colors+2
185+  62BB ED 5B 30 80 >        ld de,(fill_colors_ptr)
185+  62BF B7          >        or a
185+  62C0 ED 52       >        sbc hl,de
185+  62C2 E1          >        pop hl
185+  62C3 C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
185+  62C6 D1          >        pop de
186+  62C7
187+  62C7                  ; Last value
188+  62C7 21 36 80         ld hl,fill_colors_end-1
189+  62CA 22 30 80         ld (fill_colors_ptr),hl
190+  62CD
191+  62CD                  ; Test increment
192+  62CD CD 1B 80         call inc_fill_colors_ptr
193+  62D0                  ; Test that pointer wraps around and points to first line
194+  62D0                  TEST_MEMORY_WORD fill_colors_ptr, fill_colors
194+  62D0 D5          >        push de
194+  62D1 E5          >        push hl
194+  62D2 21 32 80    >        ld hl,fill_colors
194+  62D5 ED 5B 30 80 >        ld de,(fill_colors_ptr)
194+  62D9 B7          >        or a
194+  62DA ED 52       >        sbc hl,de
194+  62DC E1          >        pop hl
194+  62DD C4 34 60    >        call nz,UNITTEST_TEST_READY_FAILURE ; de = (addr)
194+  62E0 D1          >        pop de
195+  62E1
196+  62E1 C9               ret
197+  62E2
198+  62E2                  ENDMODULE
199+  62E2
200+  62E2
# file closed: unit_tests.asm
 43   62E2
 44   62E2              ;===========================================================================
 45   62E2              ; main routine - the code execution starts here.
 46   62E2              ; Sets up the new interrupt routine, the memory
 47   62E2              ; banks and jumps to the start loop.
 48   62E2              ;===========================================================================
 49   62E2              main:
 50   62E2                  ; Disable interrupts
 51   62E2 F3               di
 52   62E3
 53   62E3                  ; Setup stack
 54   62E3 31 D3 63         ld sp,stack_top
 55   62E6
 56   62E6                IF 0
 57   62E6 ~                ld b,1
 58   62E6 ~            start_wait_loop:
 59   62E6 ~                ld de,PAUSE_TIME
 60   62E6 ~                call pause
 61   62E6 ~                nop
 62   62E6 ~                djnz start_wait_loop
 63   62E6                ENDIF
 64   62E6
 65   62E6                  ; CLS
 66   62E6 CD 10 60         call clear_screen
 67   62E9 CD 1B 60         call clear_backg
 68   62EC
 69   62EC                  ; Init
 70   62EC 21 32 80     lbl1:    ld hl,fill_colors
 71   62EF 22 30 80         ld (fill_colors_ptr),hl
 72   62F2 11 00 58         ld de,COLOR_SCREEN
 73   62F5
 74   62F5              main_loop:
 75   62F5                  ; fill line with color
 76   62F5 2A 30 80         ld hl,(fill_colors_ptr)
 77   62F8 7E               ld a,(hl)
 78   62F9 CD 08 80         call fill_bckg_line
 79   62FC
 80   62FC                  ; break
 81   62FC D5               push de
 82   62FD 11 88 13         ld de,PAUSE_TIME
 83   6300 CD 01 60         call pause
 84   6303 D1               pop de
 85   6304
 86   6304                  ; next line
 87   6304 CD 1B 80         call inc_fill_colors_ptr
 88   6307
 89   6307 18 EC            jr main_loop
 90   6309
 91   6309
 92   6309
 93   6309              ;===========================================================================
 94   6309              ; Stack.
 95   6309              ;===========================================================================
 96   6309
 97   6309              ; Stack: this area is reserved for the stack
 98   6309              STACK_SIZE: equ 100    ; in words
 99   6309
100   6309
101   6309              ; Reserve stack space
102   6309 00 00            defw 0  ; WPMEM, 2
103   630B              stack_bottom:
104   630B 00 00 00...      defs    STACK_SIZE*2, 0
105   63D3              stack_top:
106   63D3 00 00            defw 0  ; WPMEM, 2
107   63D5
108   63D5
109   63D5
110   63D5
111   63D5              ; Fill up to 65535
112   63D5                  ; defs 0x10000 - $
113   63D5
114   63D5
115   63D5                  SAVESNA "z80-sample-program.sna", main
116   63D5
# file closed: main.asm
